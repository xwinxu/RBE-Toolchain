<!DOCTYPE HTML>
<html>

    <div class="topnav">
        <a href="https://github.com/xwinxu/RBE-Toolchain">Github</a>
        <a class="active" href="#home">Home</a>
    </div>


   <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        .topnav {
            overflow: hidden;
            background-color: #555;
        }
        .topnav a {
            float: right;
            color: #777;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
            font-size: 19px;
        }
        .topnav a:hover {
            background-color: #9898B0;
            color: black;
        }
        .topnav a.active {
            background-color: #9898B0;
            color: white;
        }
        
    *{
        box-sizing: border-box;
    }
    .column3 {
        float: left;
        width: 30%;
        padding: 5px;
    }
    .column2 {
        float: left;
        width: 50%;
        padding: 5px;
    }
    .row::after {
        content: "";
        clear: both;
        display: table;
    }
    .collapsible {
        background-color: #555;
        color: white;
        cursor: pointer;
        padding: 15px;
        width: 100%;
        border: none;
        text-align: left;
        outline: none;
        font-size: 16px;
    }
    .active, .collapsible:hover {
        background-color: #9898B0;
    }
    
    .collapsible:after {
        content: '\002B';
        color: white;
        font-weight: bold;
        float: right;
        margin-left: 5px;
        overflow: visible;
    }
    .active:after {
        content: "\2212";
        overflow-y: auto;
    }
    
    .nestcontent {
        padding: 0 15px;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.2s ease-out;
        background-color: #f1f1f1
    }
    .content {
        padding: 0 14px;
        max-height: 0;
        overflow: auto;
        transition: max-height 0.2s ease-out;
        background-color: #f1f1f1;
    }
    </style>
</head>

<body>

<style type="text/css">
<!--
.tab {margin-left: 40px;}
-->
table {
      font-size: 14px;
        margin-left:auto;
          margin-right:auto;
            border-collapse: collapse;
        }
        table th {
              font-size: 14px;
                font-weight: bold;
                  border: 2px solid #999999;
                    padding: 2px 7px;
                }
                table td {
                      border: 2px solid #999999;
                        padding: 7px 7px;
                    }
</style>

<header>
<h1> Points to Discuss </h1>
</header>

    <button class="collapsible">rules-docker Migration</button>
    <div class="content">
    <p>    
    <a href="">TBA </a>
    </p> </div>

    <button class="collapsible">Notes (General)</button>
    <div class="content">
    <p>
        - How does outputs work: <a href="https://docs.bazel.build/versions/master/skylark/lib/globals.html#rule.outputs">outputs ref</a>
    </p> </div>


    <h1>Quick Reference</h1>

    <button class="collapsible">Links</button>
    <div class="content">
    <p class="tab">
    <a href="">GDrive</a>
    <br>
    <a href="https://docs.google.com/document/d/1GeCVTbbiKlQurp6E7h926fYJneWMEEiGua7Anw6WouE/edit#heading=h.j9kk3zi9s6ax">Project Docs</a>
    <br>
    <a href="https://docs.docker.com/reference/" target="_blank">Docker Reference Docs</a>
    <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile Ref</a>
    <br>
    <a href="https://docs.bazel.build/versions/master/skylark/lib/skylark-overview.html">Bazel APIs</a>
    <a href="https://github.com/bazelbuild/examples/tree/master/rules">Bazel Examplars</a>
    </div>

    <button class="collapsible">Runs/Command Logs</button>
    <div class="content">
        <p class="tab">
        <a href="">Commands</a>
        <br>
    </div>
   

<header>
<h1> To Read </h1>
</header> 

<button class="collapsible">To be Read</button>
<div class="nestcontent">

    <button class="collapsible">Docker + Bazel Documentation<button>
    <div class="content">

    </div>
</div>


<button class="collapsible">Read</button>
<div class="nestcontent">

    <button class="collapsible">Docker + Bazel Documentation<button>
    <div class="content">

    </div>
</div>

<header>
<h1> Better rules-docker container registry backend in Go </h1>
</header>

<button class="collapsible">Week 1: Ramp-up</button>
<div class="nestcontent">

    <button class="collapsible">May 27 2019</button>
    <div class="content">
        <p>
        -First day; orientation + setting up
        <br>
        -Started reading papers + discussing project ideas
        <br>
        - Installed Docker, ran simple programs and followed tutorials on the Docker site 
        <br>
        - Dockerfile: a portable Python runtime as an image, no installation necessary. Base Python image is in the build, so alongside the app's code, the dependencies and runtime all travel together.
        <br>
            - Define a container with Dockerfile: what goes on in the env inside container, access to resources (networking interface, disk drives, map ports to outer world, 
            be specific about what files to copy into env)
        <br>
        - Note: Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable.
        <br>

        - Permission errors: make sure to do `newgrp docker` to run docker commands and escape the need for `sudo` OR (logout then back in: `sudo adduser $USER docker`)
        <br>
        Docker Commands
        <pre><code>
        ## List Docker CLI commands
        docker
        docker container --help

        ## Display Docker version and info
        docker --version
        docker version
        docker info

        ## Execute Docker image
        docker run hello-world

        ## List Docker images in MACHINE'S LOCAL DOCKER REGISTRY
        docker image ls

        ## List Docker containers (running, all, all in quiet mode)
        docker container ls
        docker container ls --all
        docker container ls -aq
        </code>
        </pre>
        <br>
        - Ensure that Docker environment is set up: <pre><code>>docker run hello-world</code></pre>
        <br>
        <a href="https://docs.google.com/document/d/1_eXqIgcsZEbxZtBNVbVpdXMC01Pa2DTNXjqhsL1Kh9g/edit">Google Docs log/notes</a>
        <pre><code>
            ## Prior to creating this image, create a Dockerfile and requirements.txt along with app.py
            ## Create a Docker image, name it using the --tag option
            docker build --tag=friendlyhello .

            ## To find the build image, look at local Docker image registry:
            docker image ls

            ## Notice how tag defaults to latest^^, full syntax: --tag=friendlyhello:v0.0.1

            ## Running the app: mapp machine's port 4000 to container's published port 80 with -p (1)
            ## the container won't know that we've mapped port 80 of container to 4000, so the url is just localhost:4000
            docker run -p 4000:80 friendlyhello

            ## Run in detached mode in background
            docker run -d -p 4000:80 friendlyhello
            ## To stop the process
            docker container stop &lt CONTAINER ID &gt
        </code></pre>
        - Essentially (1), 4000:80 remapping demonstrates difference b/t EXPOSE within eh Dockerfile and what the <pre>piublish</pre> value is set to when running docker run -p
        <br>
        - Later (2), map port 4000 on host to port 80 in container and use http://localhost
        <br>

        <br>
        <h4>Collection of images (stale program, actively distributed == container)--&gt repository --&gt collection of repos --&gt registry (code is already built) </h4>
        <pre><code>
            ## Push to registries to deploy containers to production (uplaod built image and run it elsewhere)

            ## Login to dockerhub
            docker Login

            ## Tag the image to give Docker images a version 
            docker tag &ltimage&gt &ltusername&gt/&ltrepository&gt:&lttag&gt

            ## Upload tagged image to repository, then it's public and has a pull command
            docker push username/repo:tag

            ## Pull and run image from remote repo (3)
            docker run -p 4000:80 &ltusername&gt/&ltrepository&gt:&lttag&gt

        </code></pre>
        - Docker pulls it (3) from the repo IFF it isn't available locally
        <br>
        - No need to install anything on host machine to run the image (which pulls the image and has all dependencies in it already)

        <br>
        Basic Docker Commands
        <pre><code>
            docker build -t friendlyhello .  # Create image using this directory's Dockerfile
            docker run -p 4000:80 friendlyhello  # Run "friendlyhello" mapping port 4000 to 80
            docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode
            docker container ls                                # List all running containers
            docker container ls -a             # List all containers, even those not running
            docker container stop <hash>           # Gracefully stop the specified container
            docker container kill <hash>         # Force shutdown of the specified container
            docker container rm <hash>        # Remove specified container from this machine
            docker container rm $(docker container ls -a -q)         # Remove all containers
            docker image ls -a                             # List all images on this machine
            docker image rm <image id>            # Remove specified image from this machine
            docker image rm $(docker image ls -a -q)   # Remove all images from this machine
            docker login             # Log in this CLI session using your Docker credentials
            docker tag <image> username/repository:tag  # Tag <image> for upload to registry
            docker push username/repository:tag            # Upload tagged image to registry
            docker run username/repository:tag                   # Run image from a registry
        </code></pre>

        <h3>Scaling Applications</h3>
        - Services: diff pieces of app (containers in production)
        <br>
        - Each service runs one image (codifies the way the image runs -- ports to use, # of replicas of container to be ran for apt capacity etc)
        <h3>Services: YAML file defines how Docker container should behave in production</h3>
        <pre><code>
            ## View all services associated w/ getstartedlab stack
            docker stack services &ltname of stack&gt

            ## Task == single container running a service, list them:
            docker service ps getstartedlab_web

            ## Scale the app: change the replicas value in docker-compose.yml
            ## Docker performs an in place update
            docker stack deploy -c docker-compose.yml getstartedlab

            ## Take down the app and swarm
            docker stack rm &ltservice name&gt

            ## Take down the swarm
            docker swarm leave --force

            ####### Command Summary ########
            docker stack ls                                            # List stacks or apps
            docker stack deploy -c <composefile> <appname>  # Run the specified Compose file
            docker service ls                 # List running services associated with an app
            docker service ps <service>                  # List tasks associated with an app
            docker inspect <task or container>                   # Inspect task or container
            docker container ls -q                                      # List container IDs
            docker stack rm <appname>                             # Tear down an application
            docker swarm leave --force      # Take down a single node swarm from the manager

        </code></pre>

        <a href="https://docs.google.com/document/d/1DUXGYiSKB08tziqCUj3DvSXNiRHBB-pf1AKPSugfJbg/edit?usp=sharing">Docker Classroom Notes</a>
        <br>
        <a href="https://docs.docker.com/engine/reference/commandline/exec/">Docker CLI Commands</a>
        <h3>Dockerfile</h3>
        <pre><code>
            ## Specify base image to use as starting point for new image created
            FROM repo:latest 

            ## Copy files from Docker host into image at a known location
            ## Below, we copy a file into the image (usr/share/nginx/html is where the html files are stored for the web app)
            COPY index.html /usr/share/nginx/html

            ## Document which ports the app will use
            EXPOSE 80 443

            ## What command to run when a container is started from the image, specifying command and run time args
            CMD ["nginx", "-g", "daemon off;"]
        </code></pre>
        Use <pre> docker image build </pre> to create new Docker image using the instructions in Dockerfile (make sure to use current dir as build context)
        <br>
        <h3>Modify a running container and see changes in real time (run a bind mount)</h3>
            <pre><code>
                ## Run a bind mount
                docker container run --detach 
                --publish hostport:containerport 
                --name appname --mount type=bind, source="$(pwd)", \
                    target=baseimage(somewhere inside the container, i.e. where html files are stored for web app) \
                     $DOCKERID(exported)/app_name:v1.0(version number)
            </code></pre>
        - Can use <pre>docker exec -it &ltapp name&gt</pre> to access the running container and modify the files stored there, OR 
        <br>
        <br>
        - load the local index.html file and make additional changes (we can modify the index.html in the local filesystem, but WE HAVE NOT ACTUALLY CHANGED THE DOCKER IMAGE
        <br>
        THAT THE CONTAINER WAS STARTED FROM)
        <br>
        - Check by running <pre>docker rm --force &ltapp_name&gt</pre> without a bind mount
        <br>
        - Can check all images made, and can run them all simultaneously (just change the port number and name for each container ran)
        </p>
    </div>

    <button class="collapsible">May 28/29 2019</button>
    <div class="content">
        <p>
            - Hermetic toolchains: hermetic builds are insensitive to the libraries/software installed on the build machine (build depend on known 
            <br>version of build tools (compilers) and dependencies (libraries))
            <br>
            - Use xdot to visualize Bazel query graph
            <pre>xdot &ltbazel query --nohost_deps --noimplicit_deps 'deps(//main:hello-world)' --output graph)</pre>
            <a href="https://docs.google.com/document/d/1BH4SnpwerHFjFx-k7NO7exqV87BoDkxBI9rBReYOehs/edit?usp=sharing" target="_blank">Bazel Build Notes</a>
            <br>
            <h3>Bazel Rule Summary</h3>
            <pre><code>
                - ctx = context (environment containing all dependencies and relevant resources to target eing called)
                - ctx.actions: actions taken in the context (i.e. shell commands in different contexts, diff workdir and diff env variabels)
                    - .actions: tracks what actions we are taking (Bazel is blind to I/O, so needs to know what is beings used to generate what files)
                    - hence we pass in the commands along with the input and output files
                    - so if we need file X.o, Bazel will figure out how to generate it by finding a target that outputs it
                    - mnemonic is name for an action that is easy to recognize
                    - use_default_shell = True
                - Compiling: -c means compile BUT DO NOT LINK 
                             -o is just an alternate output name you can specify 
                - Linking: take the .o files and make them an executable by connecting them together 
            </code></pre>
        </p>
    </div>

   <button class="collapsible">May 30 2019</button>
    <div class="content">
        <p>
        <h3>Bazel Provider Usage Summary</h3>
        - For each rule that is depended on by another, the implementation function must return a CcInfo provider type (aka a struct)
        <br>
        - Define this struct as a global variable, instantiate a provider and set its fields to apt variable names
        <br>
        - Now when returning this, make sure to access the value in the ctx.attr field and pass it in to make this data visible to the next rule depending on it: <pre>return [heddy(x = ctx.attr.x)]</pre>
        - This next rule down the chain will now be able to access the information in the provider, just be sure to add this into the attr of the rule definition: <pre>"deps": attr.label_list(providers = [heddy]),</pre>
        <br>
        Issue:<br>
        - Why doesn't the shell command work?? Used this instead (check git commit) `ctx.actions.write(output = ctx.outputs.out, content = str(result))`
        <br>

        <h3><a href="https://docs.bazel.build/versions/master/skylark/rules.html">Quick Basel API Ref</a></h3>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/ctx.html#aspect_id">ctx</a>
        <a href="https://docs.bazel.build/versions/master/skylark/rules.html#providers">providers</a>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/Label.html">label</a>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/Target.html">target</a>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/globals.html#rule.outputs">globals</a>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/actions.html#run">actions</a>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/attr.html#output">attr</a>
        <a href="https://docs.bazel.build/versions/master/skylark/depsets.html">depsets</a>
        <br>
        <a href="https://docs.bazel.build/versions/master/skylark/lib/CcInfo.html">CcInfo (for linking etc)</a>
        <a href="https://github.com/bazelbuild/rules_cc/blob/master/examples/my_c_archive/my_c_archive.bzl">CcInfo example</a>
        <br>
        <a href="https://github.com/bazelbuild/rules_cc/blob/master/examples/my_c_archive/BUILD">dependency chain example</a>

        </p>
    </div>

   <button class="collapsible">May 31 2019</button>
    <div class="content">
        <p>
            <h2><a href="https://github.com/bazelbuild/rules_docker">Bazel Container Image Rules</a></h2>
            - Bazel rules to build Docker images
            <br>
            - Build images with `container_image` deterministic and reproducible
            <br>
            - same build hashes to same SHA256 code
            <br>
            <h3><a href="https://docs.google.com/document/d/180tVU_dL9eMJpwWpDg39sqQbN00X7LNVP78gE_B9vnc/edit?usp=sharing">Detailed rules-docker notes</a></h3>
            <h3><a href="https://docs.google.com/document/d/1BH4SnpwerHFjFx-k7NO7exqV87BoDkxBI9rBReYOehs/edit#">Bazel Reference</a></h3>
            <h2>rules-docker Summary</h2>
            <pre><code>
                - A layer is an instance of an image
                    - Docker image -> do stuff on Docker image
                    - Don't add/delete files from image, but from a layer
                - Every time a command is run -> new layer created
                - WORKSPACE -> stuff in my "project" that I want other projects to call
                - Digest -> after downloading, run the sha256 hash on entire WORKSPACE file, and compares that hash to the digest &lt=&gt EXPOSED
                - @ubuntu1604/image &lt=&gt &ltproject&gt/&ltfile_to_get&gt -> WORKSPACE (container_image(0))
                    - from going online, currently we see ubuntu1604 (outdated), it's actually 1804 we are getting (mislabelled) as the default
                    - //image: use tag (image) to get 1604 version

                - Repository rule (meta rule): container_pull (prefetch, blueprint), just pulls once
                    - what can be pulled
                    - exposes it as sth that exists (use 10x in 10 diff build rules, pull once, use it 10x)
                    - all the info to download stuff from the server
                    - pulls + provides it to anyone who wants to use it
                - Regualr rule: container_image: uses a pulled image (unse in conjunction w/ pull)
                    - this is an actual rule that can be called by Bazel
                    - base=starting point to which you then exectute commands -> point to any container image (i.e. a file)
                        - takes a path to an image
                    - access image by going to project @ which it was downloaded
                    - name="name of the pseudo project"
                        - @: reference the project and access the image inside of it via //image (default, special way of accessing the only thing stored inside)

                - Tagging: under the same server name, under same image name, specifies which particular image is wanted
                    - sth you can come back to

                - Layers: make up images, like each change or command to the file system, a currrent working image
                    - stack up, gets birds eye view compresed (i.e. a new image)
                    - can use this new iamge as another base, and can do stuff 
                    - almost like version control, except there is no conflicts because no branching, so always one that is more "recent" -> use that one
                    - layers contain "diffs" of what was done
                    - i.e. versions of a file system: run test, compile code, download source code -> base image

                - WORKSPACE: root of a project (aka where the WORKSPACE file is placed)
                    - the // is "root" of project currently in
                        - i.e. bazel == // in our case
                            - // or bazel in our code example is the dir where docker stores its images (i.e. bazel/examples to access)
                    - entrypoints can "override" if a layer of the image also has the entrypoint (go_helloworld and reverse example)
                    - if same project, don't need @?
                        - //examples:go_helloworld can just be :go_helloworld
                    - inside difference projects (or packages), cannot access files "1 level above" (i.e. b/t packages)
                        - use WORKSPACe file to allow targets in one BIULD to access stuff in the other server system 
                    - WORKSPACE is essentially: in a project on WORKSPACE, depend on thing (i.e. a server on the internet)
                        - tell the BUILD what things it may/can access outside of its immediate project

            </code></pre>

            <a href="https://tour.golang.org/welcome/2">A tour of Go></a>
        </p>
    </div>

</div>

<button class="collapsible">Week 2: go-registry vs python</button>
<div class="nestcontent">
    <button class="collapsible">June 3 2019</button>
    <div class="content">
        <p>
        </p>
    </div>
    
    <button class="collapsible">June 4 2019</button>
    <div class="content">
        <p>
        </p>
    </div>
    
    <button class="collapsible">June 5 2019</button>
    <div class="content">
        <p>
        </p>
    </div>

    <button class="collapsible">June 6 2019</button>
    <div class="content">
        <p>
        </p>
    </div>
   
    <button class="collapsible">June 7 2019</button>
    <div class="content">
        <p>
        </p>
    </div>
</div>


<script>
var coll = document.getElementsByClassName("collapsible");
var i;
for (i = 0; i < coll.length; i++){
    coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.maxHeight){
            content.style.maxHeight = null;
        } else {
            content.style.maxHeight = content.scrollHeight + "px";
            var parentNode = this.parentNode;
            if (parentNode.className == "nestcontent") {
                parentNode.style.maxHeight = parentNode.scrollHeight + content.scrollHeight + "px";
            }
        }
    });
}
</script>

</body>
</html>
